<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[类与对象]]></title>
    <url>%2F2017%2F05%2F29%2F%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[人世起起落落 左手边上演的华灯初上 右手边是繁华落幕的星点余光 1.编程的发展阶段 机器语言 面向过程的语言 ​ 语言把代码组织成称为过程或函数的块 ​ 自顶向下，逐步求精。 面向对象语言 ​ 特性：封装性、继承性、多态性。 ​ 封装性：将数据和对数据的操作封装在一起，通过抽象，即从集体的实例中抽取共同的性质形成一般的概念。eg:类 ​ 继承性：子类可以继承父类的属性和功能，既继承了父类所具有的数据和数据上的操作，同时又可以增添子类独有的数据和数据上的操作。 ​ 多态性： ​ 1.操作名称的多态性： ​ 多个操作具有相同的名字，但这些操作所接收的信息类型不同 。 ​ 2.与继承相关的多态 ​ 同一个操作被不同类型对象调用时可能产生不同的行为。 2.类 类的声明 ​ 1.声明规则： ​ 类名若使用拉丁字母，名字的首字母大写。 ​ 类名易识别，见名知意 ​ 2.举例： class People{…} class 汽车{…} 类体 ​ 组成： ​ 一对{}以及之间的内容，内容由变量的声明和方法的定义两部分构成 成员变量和局部变量 ​ 1.类的成员变量：在类体的变量部分被声明的变量 ​ 2.类的局部变量：在类体的方法体中声明的变量和方法的参数 ​ 3.变量的类型：整型、浮点型、字符型、数组、对象、接口。 ​ 4.变量的有效范围： ​ 成员变量在整个类内都有效。 ​ 局部变量只在声明它的方法体中有效 ​ 方法参数在整个方法内有效。 ​ 方法体的局部变量从声明它的位置之后开始有效。 ​ 5.实例变量和类变量 ​ 成员变量分为实例变量和类变量. ​ 类变量：使用关键字static修饰的变量。也称为静态变量、static变量 ​ 实例变量：除了类变量之外 ​ 6.编程风格 ​ 一行一变量，方便注释。 ​ 变量的名字符合规定外，名字的首字母使用小写；变量名字有多个变 ​ 量组成，从第二个单词开始首字母大写。 ​ 见名知意。 方法 ​ 类的类体由变量的声明和方法体定义组成。 ​ 方法的定义：方法声明+方法体； ​ 格式： 方法声明部分{ 方法体的内容;} 方法的声明 ​ 方法的声明包括：方法名+方法的返回类型 eg:float area(){...} ​ 方法重载 ​ java中多态分为两种：重载+重写 ​ 功能的多态性：向功能传递不同的消息，以便让对象根据相应的消息来产生相应的行为。 ​ 功能多样性即方法重载 ​ 方法重载：一个类中可以有多个方法具有相同的名字，但这些方法的参数必须不同，即或者是参数的个数不同，或者是参数的类型不同。 ​ 【注意】方法的返回类型和参数的名字不参与比较，即如果两个方法的名字相同，即使类型不同，也必须保证参数不同。 构造方法 ​ 名字和所在类的类名相同，没有类型，构造方法可以重载。 123456789101112class 长方形&#123; float 长; float 宽; 长方形()&#123; 长=29; 宽=48; &#125; 长方形(float a,float b)&#123; 长=a; 宽=b; &#125;&#125; 类方法和实例方法 ​ 类中的方法：实例方法+类方法 ​ 实例方法：方法类型前不加static修饰 ​ 类方法（静态方法）：方法前加static 123float:float max(int x,int y)&#123;&#125;//实例方法static float min(int x,int y)&#123;&#125;//类方法 【注意】 1.对成员变量的操作只能放在方法中，方法可以对成员变量和该方法体中声明的局部变量进行操作。 123456789101112ture: class A&#123; int a=12; float b=12.5f; &#125;flase: class S&#123; int a; float b; a=12;//false, b-12.5f;//false &#125; ​ 2.实例方法能操作类变量和成员变量，而类方法只能操作类变量。 12345678910111213class A&#123; int a; static int b; void f(int x,int y)&#123; a=x; b=y; &#125; static void g(int z)&#123; a=x;//非法，只可以对类变量进行操作 b=2;//合法 &#125; &#125; ​ 3.对象 创建对象 对象的声明 ​ 类名 对象名; 为对象分配内存 对象的内存模型 People p=new people(); 分配内存，并将返回一个引用给对象变量p; 通过这个引用可以调用类中的属性和方法。 使用对象 ​ 抽象的目的是产生类，而类的目的是创建具有属性和行为的对象。对象可以操作自己的变量产生类，也能调用。 对象操作自己的变量（对象的属性）： 对象.变量 对象调用类中的方法：对象.方法 对象的引用和实体 堆：运行时的数据结构，是一个大的存储区域，用于支持动态的内存管理； java的对象在堆中分配内存，对象的引用是在栈中分配内存空间。 4.参数传值 基本的数据类型参数的传值 ​ 方法被调用时，如果方法有参数，参数必须要实例化，即参数必须有具体的值 ​ java中方法的所有参数都是传值的，即方法中的参数的值是调用者指定值一个副本。即如果方法改变参数的值，不会影响向该参数”传值”的变量的值，反之亦然。 ​ 基本数据类型的参数，向该参数传递的值的级别不可以高于该参数的级别. 12345678910111213141516171819public class A&#123; double width; void setA(double width)&#123; this.width=width; &#125; double getA()&#123; return width; &#125;&#125;public class Example&#123; public static void main(String args[])&#123; A a=new A(); double w=2.3; a.setA(w); System.out.println(a.getA());//2.3 w=12; System.out.println(a.getA());// 2.3 &#125;&#125; ​ 引用类型参数的传值 ​ 当参数是引用类型时，”传值”传递的是变量中存放的是”引用”，而不是变量所引用的实体。 可变参数 在声明方法时，不给出参数列表中从某项到最后一项的名字和个数，但这些参数的类型必须相同。 public void f(int … x) x是方法f的参数列表中可变参数的”参数代表”。 又有： public void f(double a,int …x) 有理数的封装 5.对象的组合 一个类可以把对象作为自己的 成员变量，即该对象可以将其他对象作为自己的组成部分。 6.static关键字 实例变量和类变量的区别 ​ 不同对象的实例变量将被分配不同的内存空间，如果类中有类变量，那么所有的对象的这个类变量都将分配相同的一处内存，改变其中的一个对象的这个类变量会影响到其他对象的这个类变量。即对象共享类变量。 ​ 类变量内存空间直到程序退出才被释放。 ​ 类变量可以通过某个对象访问，也可以使用类名直接访问。实例变量只能通过对象访问。 实例方法和类方法的区别 ​ 类方法可以通过某个对象访问，也可以使用类名直接访问。实例方法只能通过对象访问。 ​ 类方法的使用情景：如果一个方法不需要操作实例成员变量就可以实现某种功能，就可以将此方法声明为类方法。 12345678910111213141516class A&#123; int x,y,z; static int getCon(int start,int end)&#123; int sum; for(int i=start;i&lt;=end;i++)&#123; sum=sum+i; &#125; return sum; &#125;&#125;public class Exam&#123; public static void main(String args[])&#123; int resust=A.getCon(1,100); System.out.println(result); &#125;&#125; ​ 7.this关键字​ 【注意】this表示某个对象，this可以出现在实例方法和构造方法中，但不可以出现在类方法中。 在构造方法中使用this ​ 当this关键字出现在类的构造方法，代表该构造方法所创造的对象。 12345678910111213141516public class People&#123; int leg,hand; String name; People(String s)&#123; name=s; this.init();//this可以省略 &#125; void init()&#123; leg=2; hand=2; System.out.println(name+"有"+hand+"只手"+leg+"条腿"); &#125; public static void main(String args[])&#123; People boshi=new People("bushi"); &#125;&#125; ​ 在实例方法中使用this ​ 实例方法可以操作类的成员变量，当实例变量出现在实例方法中时，默认格式： this.成员变量 ​ 当static成员变量在实例方法中出现时，默认格式：类名.成员变量 ​ 8.访问权限 私有变量和私有方法 公有变量和公有方法 友好变量和友好方法 受保护的成员变量和方法 public类和友好类 9.基本数据类型的类封装 Double和Float类 Byte、Short、Interger和Long类 Character类 自动拆箱和装箱]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承与接口(二)]]></title>
    <url>%2F2017%2F05%2F22%2F%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%8E%A5%E5%8F%A3(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[一二三四五，上山打老虎 7.对象的上转型对象什么是对象的上转型对象？​ 假设A类是B类的父类，当用子类创建一个对象，并把这个对象的引用放到父类的对象中,如： 123456eg:A a=new B();或：A a;B b=new B();a=b; 称对象a是对象b的上转型对象。 上转型对象的特点：​ 上转型对象不能操作操作子类新增的成员变量（失掉了这部分属性），不能调用子类新增的方法（失掉了一些功能）。 ​ 上转型对象可以访问子类继承或隐藏的成员变量，也可以调用子类继承的方法或子类的重写方法。若子类重写了父类的方法，则上转型对象调用的方法一定是重写的方法。 注：可以将上转型对象强制转换成子类对象，这样，该对象又具备了子类对象的所有的功能和属性。 1234567891011121314151617181920212223242526272829303132333435363738eg:Anthropoid.javapublic class Anthropoid&#123; double m=12.5; void crySpeak(String s)&#123; System.out.println(s); &#125;&#125;People.javapublic class People extends Anthropoid&#123; char m='A'; int n=60; void computer(int a,int b)&#123; int c=a+b; System.out.println(a+"加"+b+"等于"+c) &#125; void crySpeak(String s)&#123; System.out.println(m+"**"+s+"**"+m); &#125;&#125;Example.javapublic class Example&#123; public static void main(String args[])&#123; People people=new People(); Anthropoid monkey=people;//monkey是对象的上转型对象 monkey.crySpeak("I love this game!");//等同于调用了People的 // 重写方法 //monkey.n=100;//非法，n是子类中新增的成员 //monkey.computer(12,19); //非法，computer是新增方法 System.out.println(monkey.m);//操作隐藏的m，不同于people.m System.out.println(people.m);//操作子类的m People zhang=(People)monkey; //强制转换为子类型 zhang.computer(55,33); zhang.m='T'; //可以调用子类型的全部属性和方法 System.out.println(zhang.m); &#125;&#125; 8.继承与多态​ 当一个类中有许多的子类，并且这些子类都重写了父类中的某个方法时，那么把子类创建的对象的引用放到一个父类的对象中，就得到了该对象的一个上转型对象。 ​ 这个上转型对象在调用这个方法时可能具有多种形态，因为不同的子类在重写父类的方法是可能产生不同的行为。 ​ 多态性是指父类的某个方法被其子类重写时，可以各自产生自己的功能 1234567891011121314151617class 动物&#123;void cry()&#123; &#125;&#125;class 狗 extends 动物&#123;void cry&#123; System.out.println("汪汪...汪汪"); &#125;&#125;class 猫 extends 动物&#123;void cry&#123; System.out.println("喵喵...喵喵"); &#125;&#125; 9.abstract类和方法​ 使用abstract修饰的类称为abstract方法，如: 12abstract class A&#123;&#125; ​ abstract方法：只允许声明，不允许实现，而且不允许final和abstract修饰同一个方法。 ​ 9.1抽象类的特点 ​ 1 .在abstract类中可以有abstract方法也可以有普通的方法 ​ 2.abstract类中不能够使用new运算符创建对象，如果一个非抽象的类是某个抽象类的子类，则它必须重写父类的方法。 注：abstract类也可以没有abstract方法。 ​ 一个abstract类是abstract类的子类，他可以重写父类的abstract方法，也可以继承这个abstract类的方法。 12345678910111213141516171819202122abstract class A&#123; abstract int sum(int x,int y); int sub(int x,int y)&#123; return x-y; &#125;&#125;class B extends A&#123; int sum(int x,int y)&#123;//普通B类继承抽象类，必须重写父类的方法 return x+y; &#125;&#125;public Example&#123; public static void main(String args[])&#123; B b=new B(); int sum=b.sum(30,20);//调用重写的方法 int sub=b.sub(30,20);//调用继承的方法 System.out.println("sum="+sum); System.out.println("sub="+sub); &#125;&#125; ​ 抽象类只关心操作，即只关心方法的名字，类型和参数，不关心这些操作具体实现的细节，即不关心方法体。细节应当由抽象类的非抽象子类去实现，这些子类可以给出具体的实例来完成程序功能的具体实现。 ​ 9.2抽象类与多态 ​ 实现原理：使用上转型对象，将abstract类声明的对象作为其子类的上转型对象，则这个上转型对象就可以调用子类重写的方法 ​ 体现了“开-闭”的程序设计原则即：允许扩展，不允许修改 12345678910111213141516171819202122232425262728eg: public abstract class Animal&#123; public abstract void cry(); public abstract String getAnimal(); &#125; public class Simulator&#123; //抽象类中定义了两个方法，具体的实现在以后子类调用的时候实现 public void playSound(Animal animal)&#123; //方法中以抽象类作为参数，animal是任何一个子类的上转型对 //象，可以调用Animal子类重写的方法,播放具体动物的声音 System.out.println("现在播放的是"+animal.getAnimalName()+"类的声音"); animal.cry(); &#125; &#125; public Dog extends Animal&#123;public void cry()&#123; System.out.println("汪汪...汪汪"); &#125; public String getAnimalName()&#123; return "狗"; &#125; &#125; public cat extends Animal&#123;public void cry()&#123; System.out.println("喵喵...喵喵"); &#125; public String getAnimalName()&#123; return "猫"; &#125; &#125; public class Example&#123;public static void main(String args[])&#123; Simulator simulator=new Simulator(); simulator playSound(new Dog()); simulator playSound(new cat()); &#125; &#125; 10.接口10.1接口的声明和使用声明： interface 接口的名字接口体：包含常量定义和方法定义：​ 接口体中只有抽象方法，没有普通的方法，而且接口体中所有常量和抽象方法的访问权限一定都是public 接口的使用：​ 一个类通过关键字implements声明自己实现一个或多个接口，如果实现多个接口，使用逗号隔开。如A类实现B和C的一个接口 ​ class A implements B,C Animal的子类Dog实现B和C的接口 ​ class Dog extends Animal implements B,C 如果一个类中实现了某个接口，那么这个类必须重写这个类的所有方法。重写接口方法时，接口中的方法一定是public abstract方法，所以在类重写接口方法时不仅要去掉abstract给出方法体，还要访问权限一定要明显的用public来修饰（否则就降低了访问权限）。 需要引用包：import java.io.* 123456789101112131415public interface Computable&#123; int MAX =100; int f(int x);&#125;public class China implements Computable&#123; int number; public int f(int x)&#123;// public关键字不要忘记！！！ int sum=0; for(int i=1;i&lt;=x;i++)&#123; sum=sum+i; &#125; return sum; &#125;&#125; ​ 类重写的接口方法以及接口中的常量可以被类的对象调用，而且常量可以用类名或接口名直接调用。 ​ 接口可以继承 ​ 声明接口时，前面加public时表明是公共接口，可以被任何一个类声明实现。如果不加public，是友好接口，可以被与该接口在同一个包中的类声明实现。 如果一个类声明实现一个接口，但是没有重写该类中的所有方法，那么这个类一定是abstract类 12345678910111213141516interface Computable&#123; final int Max=100; void speak(String s); int f(int x); float g(float x,float y);&#125;abstract class A implements Computable&#123; public int f(int x)&#123; int sum=0; for(int i=1;i&lt;=x;i++)&#123; sum+=i; &#125; return sum; &#125;&#125; 接口的思想：它可以增加许多类都需要具有的功能，而且实现相同接口类不一定有继承关系 123456789101112131415161718192021interface 收费&#123; public void 收取费用();&#125;interface 调节温度&#123; public void 调节温度();&#125;class 公共汽车 implements 收费&#123;public void 收费()&#123; System.out.println("1/元每公里");&#125;class 出租车 implements 收费,调节温度&#123; public void 收费()&#123; ... &#125; public void 调节温度()&#123; &#125;&#125; 10.3接口回调接口回调：把实现某一接口的类创建的对象的引用赋给该接口声明的接口变量中，则该接口变量就可以调用被类重写的接口方法. 123456789101112131415161718eg:interface ShowMessage&#123; void 显示商标(String s);&#125;class Tv implements ShowMessage&#123; public void 显示商标(String s)&#123; System.out.println(s); &#125;&#125;public class Example&#123; public static void main(String args[])&#123; ShowMessage sm;//声明接口变量 sm=new TV();//接口变量中存放对象的引用 sm.显示商标("长城牌电视机");//接口回调 &#125;&#125; ​ 把实现接口的类的实例的引用赋值给接口变量后该接口变量就可以回调类重写的接口方法。 10.4接口与多态​ 使用接口进行程序设计的核心思想：使用接口回调，即接口变量存放实现接口的类的对象的引用，从而接口变量可以回调实现接口方法。 10.5abstract类和接口的比较 abstract类和接口都可以有abstract方法 接口中可以有常量，不能够有变量，而abstract中可以有常量和变量 abstract类中可以有非abstract方法，而接口不可以。 ​]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>继承与接口2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[abstract类和方法]]></title>
    <url>%2F2017%2F05%2F20%2Fabstract%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[优秀的人，不是不合群，而是他们合群的人里面没有你 1.abstract类的特点 ​ abstract类中可以有abstract方法，不同于普通类，其中可以有抽象方法，也可以没有抽象方法。 1234567eg:abstract class A&#123; abstract int min(int x,int y); int max(int x,int y)&#123;return x&gt;y; &#125;&#125; ​ abstract类不能用new运算符创建对象。 如果一个 非抽象的类是某个抽象类的子类，那么他必须重写父类的方法，给出方法体。所以final和abstract不能同时修饰一个方法体。 abstract类可以没有abstract方法 如果一个abstract类是abstract类的子类，他可以重写父类的abstract方法，也可以继承这个abstract方法 123456789101112131415161718192021eg: abstract class A&#123; abstract int sum(int x,int y);//抽象类中定义了抽象的方法，具体的实现 //在调用抽象方法的类中 int sub(int x,int y)&#123; return x-y; &#125; &#125; class B extends A&#123; //类B继承了抽象类A int sum(int x,int y)&#123; //B必须对A中的抽象方法进行重写 return x+y; &#125; &#125; public class Example&#123; public static void main(String args[])&#123; B b=new B(); int sum=b.sum(30,20); //调用重写的方法 int sub=b.sub(30,20); //调用继承的方法 System.out.println(&quot;sum=&quot;+sum); System.out.println(&quot;sum=&quot;+sub); &#125; &#125; ​ 抽象类只关心方法的名字以及参数，具体的实现细节并不关心！！ 2.abstract类与多态​ 实现原理：使用上转型对象，将abstract类声明的对象作为其子类的上转型对象，则这个上转型对象就可以调用子类重写的方法 ​ 体现了“开-闭”的程序设计原则即：允许扩展，不允许修改 12345678910111213141516171819202122232425262728293031323334353637eg: public abstract class Animal&#123;public abstract void cry();public abstract String getAnimal();&#125; public class Simulator&#123; //抽象类中定义了两个方法，具体的实现在以后子类调用的时候实现public void playSound(Animal animal)&#123;//方法中以抽象类作为参数， //animal是任何一个子类的上转型对象，可以调用Animal子类重写的方法//播放具体动物的声音 System.out.println(&quot;现在播放的是&quot;+animal.getAnimalName()+&quot;类的声音&quot;); animal.cry(); &#125;&#125;public Dog extends Animal&#123;public void cry()&#123; System.out.println(&quot;汪汪...汪汪&quot;);&#125;public String getAnimalName()&#123; return &quot;狗&quot;; &#125;&#125; public cat extends Animal&#123;public void cry()&#123; System.out.println(&quot;喵喵...喵喵&quot;); &#125; public String getAnimalName()&#123; return &quot;猫&quot;; &#125;&#125; public class Example&#123;public static void main(String args[])&#123; Simulator simulator=new Simulator(); simulator playSound(new Dog()); simulator playSound(new cat()); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>abstract类与方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[你转身的一瞬，我萧条的一生 ​ 普通类中包含两部分的成员：成员变量+方法 而Java中支持另外的一种成员，内部类. 内部类：即Java中支持在一个类中声明另一个类，这样的类称之为内部类， 外嵌类：而包含内部类的类称为内部类的外嵌类。 区别与联系： ​ 内部类的外嵌类的成员变量在内部类中仍然有效，而内部类的方法已可以调用外部类的方法。在内部类中不可以声明类变量和类方法，在外嵌类的类体中可以用内部类 声明的对象作为外嵌类的成员。 内部类仅供他的外嵌类使用，其他类不可以用某个类的内部类声明对象。 类变量（静态变量）：前面加了static的变量 实例变量（对象变量）：没加static的变量 ##区别： ​ 类变量是所有对象共有，其中的一个对象将它的值改变，其他对象得到 的就是改变后的结果； 实例变量属于对象私有，某一个对象将其值改变， 类方法：使用static修饰的方法 注意：类方法使用类名.类方法（）调用，而实例方法则不可以通过类名调用；类方法不可以调用实例方法，不可以操作实例变量，因为在类创建对象之前实例变量还没有分配内存，实例方法也没有入口地址,如果一个方法不需要操作类的实例成员变量就可以实现某种功能，可以考虑类方法]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承与接口(一)]]></title>
    <url>%2F2017%2F05%2F20%2F%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%8E%A5%E5%8F%A3(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[人生如戏，而你是若不是演员？ 1.子类与父类​ 继承：利用已有的类创建新类。 先编写一个具有公共属性的一般类，再根据该一般类编写具有特殊属性的新类，新类继承一般类的状态和行为，并根据需要增加新的状态和行为。 由继承得到的类称为子类，被继承的类称之为父类。 ​ Java不支持多重继承。 2.子类的继承性​ 类包含的成员：成员变量+方法。 ​ 子类中的成员变量或方法一部分是子类自己声明的，一部分是继承父类的。 2.1 子类和父类在同一个包中的继承性​ 子类和父类在同一个包下，子类自然继承了父类中不是private的成员变量或成员方法作为自己的成员变量和成员方法。 2.2 子类和父类不在同一个包内的继承性​ 子类和父类不在同一个包内，子类继承了父类的protected、public成员作为子类的成员变量，并且继承了父类中的protected、public方法作为子类的方法，继承的成员变量或方法的访问权限保持不变。但是，若子类和父类不在同一个包内，子类不能继承父类的友好变量和友好方法。 ​ 注：友好变量：不用private、public、protected修饰的成员变量和方法被称为友好变量和友好方法 2.3protected的进一步说明​ 一个类中的protected成员变量和方法可以 被它的直接子类和间接子类继承。如：b是a的子类，c是b的子类，d是c的子类，那么，b、c、d都继承了a的protected成员变量和方法。 ​ 如果d类在d本身中创建了一个对象，那么该对象总是可以通过“.”运算符访问继承的或自己定义的protected变量和方法。但是，如果在另一个类中，如在other类中用d创建了一个对象object，该对象通过”.”运算符访问Protected变量和方法的权限如下： ​ 1.子类D中声明的protected成员变量和方法，other类和D类在同一个包内，就可以访问。 ​ 2.子类D的对象和protected成员变量或protected方法是从父类继承的，那么要一直追溯到该protected成员变量或方法的祖先类，即A类。若other类和A类在同一个包内，object对象能访问继承protected变量和 protected方法。 3.子类对象的构造过程​ 子类的构造方法没有明显的指明使用父类的哪一个构造方法，子类就调用父类不带参数的构造方法。 当用子类创建对象时，不仅子类声明的成员变量被分配了内存空间，而且父类的成员变量也被分配了内存空间，但只是将其中一部分（子类继承的那一部分）作为分配给子类对象的变量。 子类中还有一些从父类中继承的方法，这部分方法可以继承那部分未被继承的变量，所以那些看似未被利用的内充空间也并非是垃圾。 123456789101112131415161718192021222324252627282930313233eg:A.javapublic class A&#123; private int x; public void setX(int x)&#123; this.x=x; &#125; public int getX()&#123; return x; &#125;&#125;B.javapublic class B extends A&#123; double y=12; public void setY(int y)&#123; //this.y=y+x; 这里是非法的，子类未继承父类的x变量 &#125; public double getY()&#123; return y; &#125;&#125;主程序：public class Example&#123; public static void main(String args[])&#123; B b=new B(); b.setX(888); //子类虽然没有继承父类中的x变量，但是可以通过继承的父类 //的setX方法来修改X的值 System.out.println("子类对象未继承的x的值为："+b.getX()); b.y=12.678; System.out.println("子类对象的实例变量y的值是："+b.getY()); &#125;&#125; 4.成员变量的隐藏和方法重写4.1成员变量的隐藏:haha:​ 子类声明的成员变量和父类声明的成员变量同名，子类就隐藏了继承的成员变量。 ​ 子类对象以及子类自己声明定义的方法操作与父类同名的成员变量是指子类重新定义这个成员变量 ​ 注意，子类对象可以调用从父类继承的方法操作隐藏的成员变量 12345678910111213eg:class People&#123; public double x; public void setX(double x)&#123; this.x=x;&#125;public Student extends People&#123; int x; public int getX()&#123; //x=20.56; 错，x已经是int型的 return x; &#125;&#125; 4.2方法的重写​ 1.重写的语法规则 ​ 子类若可以继承某个实例方法，则该子类就可以重写这个方法； ​ 方法重写是指在子类中定义一个方法，这个方法的类型和父类的方法的类型一致，或者是父类的方法类型的子类型（所谓子类型是指如果父类的方法是类，那么允许子类的重写方法的类型是子类），并且这个方法的名字、参数个数、参数类型和父类的完全相同。 ​ 2.重写的目的 ​ 子类通过方法重写可以将父类的状态和行为改变为自身的状态和行为。 ​ 如果子类重写了父类的方法f，那么在使用子类创建对象时,对象调用方法f就是重写的方法f。 ​ 重写方法既可以操作继承的成员变量，又可以操作子类新声明的成员变量。若子类想使用被隐藏的方法，必须使用关键字super 1234567891011121314eg:calss A&#123; double f(float x,float y)&#123; return x+y; &#125; public int g(int x,int y)&#123; return x+y; &#125;&#125;class B extends A&#123; double f(float x,float y)&#123; return x*y;//子类重写父类的方法，方法的名称，参数的个数、类型都和父类 //的相同 &#125;&#125; ​ 3.改进 ​ 允许重写方法的类型是父类方法的类型的子类型，即不必完全一致。即如果父类的方法是类，那么子类中的重写方法可以是子类。 1234567891011121314151617181920212223242526272829303132333435eg:Createpeople类的子类CreateChinese重写了父类的createPeople()方法，重写方法的类型是Chinese类People.javapublic class People&#123; public void speak()&#123; System.out.println("我是People！"); &#125;&#125;Chinese.javapublic class Chinese extends People&#123; public void speak()&#123; System.out.println("我是中国人！"); &#125;&#125;Example.java class CreatePeople&#123; public People createPeople()&#123;//方法的类型是People类 People p=new People(); return p; &#125; &#125;class CreateChinese extends CreatePeople&#123; public Chinese createPeople()&#123;//重写的方法类型是People类的子类 //Chinese Chinese chinese =new Chinese(); return chinese; &#125; public class Example&#123; public static void main(String args[])&#123; CreateChinese create=new CreateChinese(); Chinese zhang=create.createPeople();//create调用重写的方法 zhang.speak(); &#125;&#125; ​ 注意：重写父类方法是不可以降低方法的访问权限。 5.super关键字5.1使用super调用父类的构造方法​ 子类不能继承父类的构造方法，若子类使用父类的构造方法，必须在再累的构造方法中使用关键字super，而且super必须是子类构造方法的头一条语句。 123456789101112131415161718192021222324eg:Student.javapublic class Student&#123; int number; String name; Student()&#123;&#125; Student(int number,String name)&#123; this.number=number; this.name=name; &#125; public int getNumber()&#123; return number; &#125; public String getName()&#123; return name; &#125;&#125;public class UniverStudent extends Student&#123; boolean isMarriage;//子类新增属性 UniverStudent(int number,String name,boolean b)&#123; surper(number,name);//调用父类的构造方法，执行 //Student(number,name); &#125;&#125; 注意：若在子类的构造方法中没有明显的写出super关键字来调用父类的某个构造方法，默认有：super();语句，即调用父类不带参数的构造方法.java就不提供默认构造方法（不带参数的构造方法），所以当父类中定义多个构造方法时，，应当包含一个不带任何参数的构造方法，以防止子类省略super时出现错误 5.2使用super操作被隐藏的成员变量和方法​ 子类中使用被子类隐藏起来的成员变量或方法，可以使用super,super.x、surper.play()访问被子类隐藏起来的成员变量x和成员方法play()。 1234567891011121314151617181920212223242526272829303132333435363738394041eg:Sum.javapublic class Sum&#123; int n; public double f()&#123; double sum=0; for(int i=1;i&lt;=n;i++)&#123; sum=sum+i; &#125; return sum; &#125;&#125;Average.javapublic class Average extends Sum&#123; double n;//子类继承的int型变量n被隐藏 public double f()&#123; double c; super.n=(int)n;//double型变量n做int转换，将结果赋给隐藏的int型变量n c=super.f();//调用父类的方法f(); return c+n; &#125; public double g()&#123; double c; c=super.f(); return c-n; &#125;&#125;Example.javapublic class Example&#123; public static void main(String args[])&#123; Average aver=new Average(); aver.n=100.5678; double res1=aver.f(); double res2=aver.g(); System.out.println("res1="+res1); System.out.println("res2="+res2); &#125;&#125; 6.final关键字6.1final类​ 可以使用final将类声明为final类，final类不能被继承，即不能够有子类 6.2final方法​ 如果使用final修饰父类的一个方法，该方法不允许子类重写。即不允许子类隐藏可以继承的final方法（不许任何修改）。 123456789101112131415161718192021eg:Example.javaclass A&#123; //final double PI; 非法，未给常量指定值 final double PI=3.1415926; //PI是常量 public double getArea(final double r)&#123;//r=89; 非法，不允许修改 return PI*r*r; &#125; public final void speak()&#123; System.out.println(&quot;您好，How&apos;s ?&quot;); &#125;&#125;class B extends A&#123; /*非法，不能重写speak()方法 public void speak()&#123;System.out.println(&quot;nihao!&quot;); &#125; */&#125; ​ ​ ​]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>继承与接口1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle中不能够删除默认表空间]]></title>
    <url>%2F2017%2F05%2F19%2Foracle%E4%B8%AD%E4%B8%8D%E8%83%BD%E5%A4%9F%E5%88%A0%E9%99%A4%E9%BB%98%E8%AE%A4%E8%A1%A8%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[博观而约取，厚积而薄发 【TABLESPACE】Oracle数据库默认永久表空间的查询及删除方法 个人分类：故障处理与分析 每一个数据库，都有一个默认永久表空间与之对应。既然冠以“默认”的称号，索引这个表空间是不允许轻易被删除的。本文给出Oracle默认表空间的查询方法以及删除方法。 1.获取数据库的默认永久表空间 此信息可以通过DATABASE_PROPERTIES视图获取。 set lines 131123456789sys@ora10g&gt; col property_name for a30sys@ora10g&gt; col property_value for a30sys@ora10g&gt; col description for a40sys@ora10g&gt; select * from database_properties where property_name=&apos;DEFAULT_PERMANENT_TABLESPACE&apos;;PROPERTY_NAME PROPERTY_VALUE DESCRIPTION 1DEFAULT_PERMANENT_TABLESPACE USERS Name of default permanent tablespace 此系统的默认永久表空间是USERS。 2.尝试删除默认永久表空间 sys@ora10g&gt; drop tablespace USERS including contents and datafiles; drop tablespace USERS including contents and datafiles * ERROR at line 1: ORA-12919: Can not drop the default permanent tablespace 此时的“ORA-12919”报错详细的记录了问题原因。 3.默认永久表空间的删除方法 既然是因为是“默认”的永久表空间不可以删除，我们仅需将默认的永久表空间指定到其他表空间，然后USERS表空间便可以被顺利删除。 1）将数据库系统的默认永久表空间调整到TBS_SEC_D sys@ora10g&gt; alter database default tablespace TBS_SEC_D; Database altered. 2）确认调整效果 123sys@ora10g&gt; select * from database_properties where property_name=&apos;DEFAULT_PERMANENT_TABLESPACE&apos;;PROPERTY_NAME PROPERTY_VALUE DESCRIPTION DEFAULT_PERMANENT_TABLESPACE TBS_SEC_D Name of default permanent tablespace 3）删除原默认永久表空间USERS sys@ora10g&gt; drop tablespace USERS including contents and datafiles; Tablespace dropped. 删除成功。 4.小结 本文给出了Oracle数据库默认永久表空间的查询及删除方法。 BTW，通过database_properties视图我们可以获取数据库很多其他默认信息。如下所示。 sys@ora10g&gt; select * from database_properties; PROPERTY_NAME PROPERTY_VALUE DESCRIPTION DICT.BASE 2 dictionary base tables version。。。。。。]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle故障分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[it's my blog]]></title>
    <url>%2F2017%2F05%2F16%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[优秀的人，不是不合群，而是他们合群的人里面没有你 我的第一篇文章]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>